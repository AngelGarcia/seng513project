/* reputation.js 
 *
 * Provides functions for calculating and updating a user's reputation score 
 *
 * In calculating the reputation of user, we focus on two primary aspects: 
 * 1) Participation/contribution (e.g. voting on issues, voting on comments, adding issues)
 * 2) Quality of contributions (e.g. offensive material, length) 
 * 
 * There is a minimum reputation level enforced for users. Users will never fall 
 * below this reputation level in order to decrease the incentive for a user 
 * to abandon their account and start over if they accumlate a large negative reputation. 
 * 
 * There is also a maximum reputation level enforced for users.  Users reputations are 
 * capped in order to prevent a few users from dominating the discussion. 
 *
 * The reputation system is based on 'actions'. For example, the action of 
 * adding an issue an issue will improve your reputation by a certain amount. 
 * Actions can affect multiple users. For example, a user voting on a issue 
 * will affect their own reputation and the reputation of the issue author.  
 * 
 *  
 * Some other possible factors and improvements that can be made to the reputation system include: 
 * Other possible factors and improvements 
 * - Factor in the length of time a user has been a part of the community 
 * - Weight people with good reputations more so that when they upvote
 *   an issue, more points will be given to the issue owner. 
 * - Factor in how recently active a user is. Active users may have more weight 
 *   than inactive users. 
 */
 
var dbAccess = require('dbAccess'), 
	wordFilter = require('wordFilter'); 

var Direction = { 'Up' : 0, 'Down' : 1 }; 
	
/* Point Parameters */
var minScore = 0; 
var maxScore = 100000; 

var signUpPoints = 10; 

var addIssuePoints = 5; 
var issueVotePoints = 1; 

var addCommentPoints = 1; 
var commentedOnPoints = 1;
var commentLengthDeduction = 1; 
var commentMaxOffensiveWordDeduction = 3; 

/* getReputation
 * Gets the reputation score of a specified user 
 *
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns the reputation score of the user 
 */
exports.getReputation = function(userId, call_back) {
	dbAccess.find('users', { properties:['reputation_score'], conditions: ['id="' + userId + '"'] }, 
		function(error, results) {
			if (error) throw error; 
			if (call_back instanceof Function) { 
				call_back(results[0].reputation_score); 
			} 
		}
	); 
}

/* addToReputation
 * Add a specified value to the reputation score 
 * 
 * 'userId' The id of the user
 * 'value' The value (positive or negative) to add to the reputation score 
 * 'call_back' The call back function which returns a possible error to a user  
 */ 
function addToReputation (userId, value, call_back) {
	exports.getReputation(userId, function(score) {
		var newScore = score + value;
		setReputation(userId, newScore, function(score) {
			if (call_back instanceof Function) { 
				call_back(score); 
			}
		});
	});
}

/* setReputation 
 * Sets the reputation of a user to a specified 
 * 
 * 'userId' The id of the user
 * 'value' The value to set the reputation score to  
 * 'call_back' The call back function which returns a possible error to a user  
 */ 
function setReputation(userId, value, call_back) {
	exports.getReputation(userId, function(score) {
		if (value < minScore) {
			resetReputation(userId);
			if (call_back instanceof Function) { 
				call_back(minScore); 
			}
		}
		else if (value > maxScore) {
			dbAccess.update('users', { values:[ 'reputation_score="' + maxScore + '"' ], 
				conditions:['id="' + userId + '"'] });
			if (call_back instanceof Function) { 
				call_back(maxScore); 
			} 
		}
		else {
			dbAccess.update('users', { values:[ 'reputation_score="' + value + '"' ], 
				conditions:['id="' + userId + '"'] });
			if (call_back instanceof Function) { 
				call_back(value); 
			} 
		}
	});
}

/* resetReputation
 * Resets the repuation score of a specified user to the lowest possible value.  
 * 
 * 'userId' The id of the user 
 */
function resetReputation(userId) {
	setReputation(userId, minScore); 
}

/* countIssues 
 * Counts the number of issues opened by a specified user 
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of issues by a user
 */
function countIssues(userId, call_back) { 
	var sql = 'SELECT COUNT(*) AS "num_issues" FROM issues WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (error) throw error;
		if (call_back instanceof Function) { 
			call_back(results[0].num_issues); 
		} 
	});
}

/* countComments 
 * Counts of the number of comments made by a user
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of comments by a user 
 */
function countComments(userId, call_back) {
	var sql = 'SELECT COUNT(*) AS "num_comments" FROM comments WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (error) throw error;
		if (call_back instanceof Function) { 
			call_back(results[0].num_comments); 
		} 
	});
}

/* getOffensiveMaterialDeduction 
 * Calculates the reputation point deduction for a given text string
 * based on the amount of offensive words within the text.  
 *
 * 'text' The string to be analyzed 
 */ 
function getOffensiveMaterialDeduction(text) {
	var maximumDeduction = commentMaxOffensiveWordDeduction; 
	var offensiveWordCount = offensiveWords.countOffensiveWords(text); 
	return (offensiveWordCount > maximumDeduction) ? -maximumDeduction : -offensiveWordCount; 
}

/* getCommentLengthDeduction
 * Calculates the reputation point deduction for a given text string
 * based on the amount of length of the text. 
 *  
 * Generally, relatively short comments (i.e. 1 - 3 words) are poor 
 * contributions to discussions. As a result, it is recommended that such comments 
 * result in a reputation point reduction to the commenter.   
 * 
 * 'text' The string to be analyzed 
 */ 
function getCommentLengthDeduction(comment) {
	var minimumCommentLength = 3; 
	var commentLength = comment.split(/\s+/).length;
	return (commentLength <= minimumCommentLength) ? -commentLengthDeduction : 0; 
}

/* updateOnIssueVote 
 * A helper function which update reputations for the issue author and voter when an issue is voted upon.
 *
 * 'issueId' The id of the issue that was voted on
 * 'userId' The id of the user who voted 
 * 'direction' The vote direction (up or down) 
 */ 
function updateOnIssueVote(issueId, userId, direction) {
	// Adjust reputation for issue author 
	dbAccess.find('issues', { properties:['user_id'], conditions: ['id="' + issueId + '"'] }, 
		function(error, results) {
			var points = (direction == Direction.Up) ? issueVotePoints : -issueVotePoints; 
			addToReputation(results[0].user_id, points);
		}
	); 
	// Adjust reputation for commenter
	addToReputation(userId, issueVotePoints); 
}

/* updateOnCommentVote 
 * A helper function which update reputations for the issue author and voter when a comment is voted upon.
 *
 * 'commentId' The id of the comment that was voted on
 * 'userId' The id of the user who voted 
 * 'direction' The vote direction (up or down) 
 */ 
function updateOnCommentVote(commentId, userId, direction) {
	// Adjust reputation for comment author 
	dbAccess.find('comments', { properties:['user_id'], conditions: ['id="' + commentId + '"'] }, 
		function(error, results) {
			var points = (direction == Direction.Up) ? commentPoints : -commentPoints; 
			addToReputation(results[0].user_id, points);
		}
	); 
	// Adjust reputation for commenter 
	addToReputation(userId, commentPoints); 
}

/* updateOnSignUp
 * Adjusts the reputation for a user when they sign-up 
 * 
 * 'name' The name of the user
 * 'email' The email of the user 
 */ 
exports.updateOnSignUp = function(name, email) {
	dbAccess.find('users', { properties:['id'], conditions: ['name="' + name + '"', 'email="' + email + '"' ] }, 
		function(error, results) {
			addToReputation(results[0].id, signUpPoints);
		}
	); 
}

/* updateOnAddComments 
 * Adjusts the reputation for the issue author and commenter when a new comment is added 
 *
 * 'issueId' The id of the issue that was commented on 
 * 'userId' The id of the user who made the comment 
 * 'comment' The comment that was added 
 */ 
exports.updateOnAddComment = function(issueId, userId, comment) {
	// Adjust reputation for issue author 
	dbAccess.find('issues', { properties:['user_id'], conditions: ['id="' + issueId + '"'] }, 
		function(error, results) {
			addToReputation(results[0].user_id, commentedOnPoints); 
		}
	); 
	// Adjust reputation for commenter 
	exports.getReputation(userId, function(score) {
		var newScore = score; 
		var lengthDeduction = getCommentLengthDeduction(comment); 
		var offensiveWordingDeduction = getOffensiveMaterialDeduction(comment); 
		newScore += addCommentPoints + lengthDeduction + offensiveWordingDeduction; 
		setReputation(userId, newScore); 
	}); 
}

/* updateOnIssueUpVote 
 * Adjusts the reputation for the issue author and commenter when an issue is voted up 
 *
 * 'issueId' The id of the issue that was commented on 
 * 'userId' The id of the user who made the comment 
 */ 
exports.updateOnIssueUpVote = function(issueId, userId) {
	updateOnIssueVote(issueId, userId, Direction.Up); 
}

/* updateOnIssueUpVote 
 * Adjusts the reputation for the issue author and commenter when an issue is voted down 
 *
 * 'issueId' The id of the issue that was commented on 
 * 'userId' The id of the user who made the comment 
 */ 
exports.updateOnIssueDownVote = function(issueId, userId) {
	updateOnIssueVote(issueId, userId, Direction.Down); 
}

/* updateOnCommentUpVote 
 * Adjusts the reputation for the comment author and commenter when an comment is voted up
 *
 * 'commentId' The id of the issue that was commented on 
 * 'userId' The id of the user who made the comment 
 */ 
exports.updateOnCommentUpVote = function(commentId, userId) {
	updateOnCommentVote(commentId, userId, Direction.Up);  
}

/* updateOnCommentDownVote 
 * Adjusts the reputation for the comment author and commenter when an comment is voted down
 *
 * 'commentId' The id of the issue that was commented on 
 * 'userId' The id of the user who made the comment 
 */ 
exports.updateOnCommentDownVote = function(commentId, userId) {
	updateOnCommentVote(commentId, userId, Direction.Down); 
}



