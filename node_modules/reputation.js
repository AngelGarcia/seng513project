/* reputation.js 
 *
 * Provides functions for calculating and updating a user's reputation score 
 *
 * The intial implementation primarly focuses a participation/contribution model.  
 * That is, certain actions (e.g. voting on isues, voting on comments), contribute
 * to a user's reputation.  
 * 
 * Other possible factors and improvements 
 * - The length of time a user has been a part of the community 
 * - Quality of comments. For example, we may want to decrease reputation 
 *   for comments which a very short, or contain offensive words. 
 * - Weight people with good reputations more so that when they upvote
 *   an issue, more points will be given to the issue owner. 
 */
 
var dbAccess = require('dbAccess'), 
	util = require('util'); 
	
var issueVoteWeight = 2;
var commentVoteWeight = 1;

/* resetReputation
 * Resets the score of a specified user 
 *
 * 'userId' The id of the user 
 */
exports.resetReputation = function(userId) {
	dbAccess.update('users', { values:[ 'reputation_score="0"' ], conditions:['id="' + userId + '"'] }); 
}

/* getReputation
 * Gets the reputation score of a specified user 
 *
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns the reputation score of the user 
 */
exports.getReputation = function(userId, call_back) {
	dbAccess.find('users', { properties:['reputation_score'], conditions: ['id="' + userId + '"'] }, 
		function(error, results) {
			if (call_back instanceof Function) { 
				call_back(results[0].reputation_score); 
			} 
		}
	); 
}

/* addToReputation
 * Add a specified value to the reputation score 
 * 
 * 'userId' The id of the user
 * 'value' The value (positive or negative) to add to the reputation score 
 * 'call_back' The call back function which returns a possible error to a user  
 */ 
exports.addToReputation = function(userId, value, call_back) {
	var sign = value < 0 ? ' - ' : ' + '; 
	var sql = 'UPDATE users SET reputation_score=reputation_score' + sign + Math.abs(value) + ' WHERE id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (call_back instanceof Function) { 
			call_back(error); 
		} 
	});
}


/* Counts the number of issues opened by a specified user 
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of issues by a user
 */
function countIssues(userId, call_back) { 
	var sql = 'SELECT COUNT(*) AS "num_issues" FROM issues WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (call_back instanceof Function) { 
			call_back(results[0].num_issues); 
		} 
	});
}

/* Counts of the number of comments made by a user
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of comments by a user 
 */
function countComments(userId, call_back) {
	var sql = 'SELECT COUNT(*) AS "num_comments" FROM comments WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (call_back instanceof Function) { 
			call_back(results[0].num_comments); 
		} 
	});
}

exports.updateOnIssueUpVote = function(issueId, userId) {
	exports.addToReputation(userId, issueVoteWeight); 
}

exports.updateOnIssueDownVote = function(issueId, userId) {
	exports.addToReputation(userId, -issueVoteWeight); 
}

exports.updateOnCommentUpVote = function(commentId, userId) {
	exports.addToReputation(userId, commentVoteWeight); 
}

exports.updateOnCommentDownVote = function(commentId, userId) {
	exports.addToReputation(userId, -commentVoteWeight); 
}

exports.resetReputation(1);  
exports.updateOnIssueDownVote(1, 1); 
exports.getReputation(1, function(score) {
	console.log(score); 
}); 



