/* reputation.js 
 *
 * Provides functions for calculating and updating a user's reputation score 
 *
 * In calculating the reputation of user, we focus on two primary aspects: 
 * 1) Participation/contribution (e.g. voting on issues, voting on comments, adding issues)
 * 2) Quality of contributions (e.g. offensive material, length) 
 * 
 * There is a minimum reputation level enforced for users. Users will never fall 
 * below this reputation level in order to decrease the incentive for a user 
 * to abandon their account and start over if they accumlate a large negative reputation. 
 * 
 * Other possible factors and improvements 
 * - Factor in the length of time a user has been a part of the community 
 * - Weight people with good reputations more so that when they upvote
 *   an issue, more points will be given to the issue owner. 
 * - Factor in how recently active a user is. Active users may have more weight 
 *   than inactive users 
 */
 
var dbAccess = require('dbAccess'), 
	util = require('util'),
	offensiveWords = require('offensiveWords'); 
	
var issueVoteWeight = 2;
var commentVoteWeight = 1;
var minimumScore = 0; 

/* resetReputation
 * Resets the score of a specified user 
 * 
 * 'userId' The id of the user 
 */
function resetReputation(userId) {
	dbAccess.update('users', { values:[ 'reputation_score="' + minimumScore + '"' ], 
		conditions:['id="' + userId + '"'] });
}

/* getReputation
 * Gets the reputation score of a specified user 
 *
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns the reputation score of the user 
 */
exports.getReputation = function(userId, call_back) {
	dbAccess.find('users', { properties:['reputation_score'], conditions: ['id="' + userId + '"'] }, 
		function(error, results) {
			if (call_back instanceof Function) { 
				call_back(results[0].reputation_score); 
			} 
		}
	); 
}

/* addToReputation
 * Add a specified value to the reputation score 
 * 
 * 'userId' The id of the user
 * 'value' The value (positive or negative) to add to the reputation score 
 * 'call_back' The call back function which returns a possible error to a user  
 */ 
exports.addToReputation = function(userId, value, call_back) {
	exports.getReputation(userId, function(score) {
		var newScore = score + value;
		if (newScore < minimumScore) {
			resetReputation(userId);
			if (call_back instanceof Function) { 
				call_back(minimumScore); 
			}
		}
		else {
			dbAccess.update('users', { values:[ 'reputation_score="' + newScore + '"' ], 
				conditions:['id="' + userId + '"'] });
			if (call_back instanceof Function) { 
				call_back(newScore); 
			} 
		}
	});
}


/* Counts the number of issues opened by a specified user 
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of issues by a user
 */
function countIssues(userId, call_back) { 
	var sql = 'SELECT COUNT(*) AS "num_issues" FROM issues WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (call_back instanceof Function) { 
			call_back(results[0].num_issues); 
		} 
	});
}

/* Counts of the number of comments made by a user
 * 
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns number of comments by a user 
 */
function countComments(userId, call_back) {
	var sql = 'SELECT COUNT(*) AS "num_comments" FROM comments WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (call_back instanceof Function) { 
			call_back(results[0].num_comments); 
		} 
	});
}

function evaluateOffensiveMaterial(text) {
	var maximumDeduction = 3; 
	var offensiveWordCount = offensiveWords.countOffensiveWords(text); 
	return (offensiveWordCount > maximumDeduction) ? maximumDeduction * -1 : offensiveWordCount * -1; 
}

function evaluateCommentLength(comment) {
	var minimumCommentLength = 3; 
	var commentLength = comment.split(/\s+/).length;
	return (commentLength <= minimumCommentLength) ? 0 : 1; 
}

exports.updateOnIssueUpVote = function(issueId, userId) {
	exports.addToReputation(userId, issueVoteWeight); 
}

exports.updateOnIssueDownVote = function(issueId, userId) {
	exports.addToReputation(userId, -issueVoteWeight); 
}

exports.updateOnCommentUpVote = function(commentId, userId) {
	exports.addToReputation(userId, commentVoteWeight); 
}

exports.updateOnCommentDownVote = function(commentId, userId) {
	exports.addToReputation(userId, -commentVoteWeight); 
}

resetReputation(1);  
exports.updateOnIssueDownVote(1, 1); 
exports.getReputation(1, function(score) {
	console.log(score); 
}); 



