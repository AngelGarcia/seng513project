/* tags.js 
 *
 * Provides functions for tagging issues
 * Dori Saba
 * sabad66@hotmail.com
 * March 3, 2011
 *
 * Future: Right now, it can only handle one-word tags. So 'tag1 tag2' will be two tags: ['tag1', 'tag2']
 * Eventually, would like to have it so that you can have more than one word tags ie 'tag1 "le tag" tag3'
 * would be ['tag1', 'le tag', 'tag2']. Currently, it would parse to: ['tag1', '"le', 'tag"', 'tag3']
 */
 
var dbAccess = require('dbAccess'),
	sqlite = require('sqlite'),
	stringUtil = require('stringUtil'); 
	util = require('util');

var MAXTAGS = 20; // Set a maximum of 20 tags per issue

/* tagIssue
 * Gets the reputation score of a specified user 
 *
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns the reputation score of the user 
 */
var tagIssue = exports.tagIssue = function(issueId, tags, call_back) {
	// First we need to check if we have a valid issueId
	dbAccess.runQuery("SELECT * FROM issues WHERE id = " + issueId  + ";", function (error, result) {
		if (error)
			util.log("error in searching for issue to tag. was the issue created successfully?");
		else {
			// Now check that we have one result
			if (result.length != 1) {
				util.log("error... we have more than 1 issue matchign id " + issueId);
				if (call_back instanceof Function) call_back(error);
			}
			else
			{
				// Split it using a regex that checks for one or more spaces
				var tagList = tags.split(/\s+/, MAXTAGS);
				// After much googling, found this nice javascript iteration pattern here:
				// http://metaduck.com/post/2675027550/asynchronous-iteration-patterns-in-node-js
				(function insertOne() {
					var t = tagList.splice(0, 1)[0]; // get the first one and reduce the list by 1
					if (!t.isNullOrEmptyOrBlank) { // Only proceed if it is a 'good' tag
						addTag(t, function(e2, tagId) { // Add the tag to the db.. the ID of the tag will be returned
							if (e2) {
								util.log("error in tagIssue.. came from addTag" + e2);
								call_back(e2);
							}
							else {
								// Now we create the relationship in the issuetags table
								dbAccess.create('issuetags', { values:['issue_id=\"' + issueId + "\"", 'tag_id=\"' + tagId + "\""] }, function(e3) {
									if (e3) {
										util.log("error creating tag relationship (tags.tagIssue)" + e3);
										call_back(e3);
									}
									else {
										//util.log("relationship from issue " + issueId + " to tag " + tagId + " added successfully");
										if (tagList.length == 0) {
											call_back();
										}
										else {
											process.nextTick(insertOne, 0); // Recursively call this wrapped function
										}
									}
								});
							}
						});
					}
				})();
			}
		}
	});
}

/* getTagId
 * Gets the id of a given tag from the tags table. Returns -1 if it doesn't exit
 * 
 * 'tag' is the id we are checking
 */
var getTagId = exports.getTagId = function(tag, call_back) {
	// Run the select query
	var q = "SELECT id FROM tags where tag = '" + tag + "';"
	dbAccess.runQuery(q, function (error, results) {
		if (error) {
			util.log("error in tags.getTagId1. " + error);
			if (call_back instanceof Function) call_back(error, -1);
		}
		else if (results.length != 0) { // If rows are returned, return the id to the callback
			if (call_back instanceof Function) call_back(undefined, results[0].id);
		}
		else
			if (call_back instanceof Function) call_back(undefined, -1); // otherwise return -1
	});
}

/* addTag
 * Adds the tag to the tags table. Returns the tag id, or -1 if there is an error.
 * 
 * 'tag' is the tag we are adding
 */
var addTag = exports.addTag = function(tag, call_back) {
	// Check if it exists
	getTagId(tag, function(error, tagId) {
		if (error) {
			util.log("error in addTag.. came from calling getTagId " + error);
			call_back(error, -1);
		}
		else if (tagId == -1) { // If it doesn't exist, insert it into the db
			dbAccess.create('tags', { values:['tag=\"' + tag + "\""] }, function(error, newTagId) {
				if (error) {
					util.log("error in addtag" + error);
					if (call_back instanceof Function) call_back(error, -1);
				}
				else {
					//util.log("Tag '" + tag + "' added to tags table with id " + newTagId);
					if (call_back instanceof Function) call_back(undefined, newTagId);
				}
			});
		}
		else {
			//util.log("Tag '" + tag + "' exists with id " + tagId);
			if (call_back instanceof Function) call_back(undefined, tagId);
		}
	});
}

getTags = function (issueId, call_back) {
	// Get a list of the tags from the db
	var q = "SELECT tag FROM tags WHERE id IN (SELECT tag_id FROM issuetags WHERE issue_id = " + issueId + ");"
	dbAccess.runQuery(q, function (error, results) {
		if (error) {
			util.log("error running query in tags.getTags. " + error);
			if (call_back instanceof Function) call_back(error);
		}
		else
			if (call_back instanceof Function) call_back(undefined, results);
	});
}

exports.getTagList = function(issueId) {
	var tagList = new Array();
	getTags(issueId, function(error, results) {
		return tagList;
	});
}


