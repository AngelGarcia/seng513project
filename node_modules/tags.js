/* tags.js 
 *
 * Provides functions for tagging issues
 * Dori Saba
 * sabad66@hotmail.com
 * March 3, 2011
 *
 * Future: Right now, it can only handle one-word tags. So 'tag1 tag2' will be two tags: ['tag1', 'tag2']
 * Eventually, would like to have it so that you can have more than one word tags ie 'tag1 "le tag" tag3'
 * would be ['tag1', 'le tag', 'tag2']. Currently, it would parse to: ['tag1', '"le', 'tag"', 'tag3']
 */
 
var dbAccess = require('dbAccess'),
	sqlite = require('sqlite');
	//wordFilter = require('wordFilter');

var MAXTAGS = 20; // Set a maximum of 20 tags per issue

/* tagIssue
 * Gets the reputation score of a specified user 
 *
 * 'userId' The id of the user 
 * 'call_back' The call back function which returns the reputation score of the user 
 */
var tagIssue = exports.tagIssue = function(issueId, tags, call_back) {
	// First we need to check if we have a valid issueId
	dbAccess.runQuery("SELECT * FROM issues WHERE id = " + issueId  + ";", function (error, result) {
		if (error)
			util.log("error in searching for issue to tag. was the issue created successfully?");
		else {
			// Now check that we have one result
			if (result.length != 1) {
				util.log("error... we have more than 1 issue matchign id " + issueId);
				call_back(error);
			}
			else
			{
				// Now we parse the tags, turn it into a list and check if each tag exists in the tags db
				tagList = tags.split(' ', MAXTAGS);
				for (i = 0; i < tagList.length; i++)
				{
					tagId = getTagId(tagList[i]);
					if(tagId == -1)
					{
						// If it's not in the tags table, we'll add it
						tagId = addTag(tagList[i]); //This function returns the id of the tag
					}
					// Now create the relationship
					dbAccess.create('issuetags', { values:['issue_id=\"' + issueId + "\"", 'tag_id=\"' + tagId + "\""] }, function() {
						util.log("relationship from issue " + issueId + " to tag " + tagId + " added successfully");
					});
				}
			}
		}
	});
}

/* getTagId
 * Gets the id of a given tag from the tags table. Returns -1 if it doesn't exit
 * 
 * 'tag' is the id we are checking
 */
var getTagId = exports.getTagId = function(tag, call_back) {
	var q = "SELECT id FROM tags where tag = '" + tag + "';"
	util.log(q);
	dbAccess.runQuery(q, function (error, results) {
		if (error) {
			util.log(error);
			call_back(-1);
		}
		else if (results.length != 0) {
			util.log("length" + results.length);
			call_back(results[0].id);
		}
		else
			call_back(-1);
	});
	//dbAccess.find('tags', { properties:['id'], conditions:['
}

/* addTag
 * Adds the tag to the tags table. Returns the tag id, or -1 if there is an error.
 * 
 * 'tag' is the tag we are adding
 */
var addTag = exports.addTag = function(tag, call_back) {
	// Check if it exists
	getTagId(tag, function(tagId) {
		if (tagId == -1) { // If it doesn't exists, insert it into the db
			var q = "INSERT INTO tags(tag) VALUES ('" + tag + "');";
			dbAccess.runQuery(q, function (error, results) {
				if (error) {
					util.log("erro in addtag");
					call_back(-1);
				}
				else {
					util.log("tag " + tag + " added to db");
					// Now get the id of it so we can return it
					dbAccess.runQuery("SELECT last_insert_rowid() \"id\";", function (error, results) {
						if (error) {
							util.log("error in addTag2");
							call_back(-1);
						}
						else {
							call_back(results[0].id);
						}
					});
				}
			});
		}
		else
		{
			util.log("can't add tag " + tag + ".. already exists with id " + tagId);
			call_back(-1);
		}
	});
}


