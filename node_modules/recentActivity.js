/* recentActivity.js 
 * Aggregates recent events (issue created, comments added, comments/issues voted) 
 * based on a person's interests in issues, topics and locations
 */ 
 
var dbAccess = require('dbAccess'),
	step = require('step'), 
	util = require('util');
	
var MAX_RESULTS = 100; 

/* getLatestIssues 
 * Returns the latest issues. A maximum number of issues to return can be specified 
 *
 * 'numIssues' The maximum number of issues to return 
 * 'callback' A callback with (error, results) 
 */ 
function getLatestIssues(numIssues, callback) { 
	var maxIssues = (numIssues < 0) ? -1 : numIssues; 
	dbAccess.find('issues', { orderby: 'created DESC', limit: maxIssues }, function(error, results) {
		callback(error, results); 
	});
}

/* getLatestComments  
 * Returns the latest comments. A maximum number of comments to return can be specified 
 *
 * 'numComments' The maximum number of issues to return 
 * 'callback' A callback with (error, results) 
 */
function getLatestComments(numComments, callback) { 
	var maxComments = (numComments < 0) ? -1 : numComments; 
	dbAccess.find('comments', { orderby: 'created DESC', limit: numComments }, function(error, results) {
		callback(error, results); 
	});
}

/* getInterests 
 * Gets the interests for a user 
 *
 * 'userId' The id of the user 
 * 'callback' A callback with (error, results) 
 */ 
function getInterests(userId, callback) { 
	dbAccess.find('interests', { conditions: ['user_id="' + userId + '"'] }, function(error, results) { 
		callback(error, results); 
	});
}

/* getUserLocation
 * Gets the location/neighborhood of a user 
 * 
 * 'userId' The id of the user 
 * 'callback' A callback with (error, results) where results is the user's neighborhood 
 */ 
function getUserLocation(userId, callback) {
	dbAccess.find('users', { properties: [ 'neighborhood' ], conditions: ['id="' + userId + '"'] }, 
		function(error, results) { 
			callback(error, results); 
		});
}

/* getRecentActivityList 
 * Returns a list of recent activity (issues and comments) 
 * 
 * 'maxResults' The maximum number of results to return 
 * 'callback' A callback which returns an object with the following properties: 
 *      type : The type of results (e.g. 'issue' or 'comment') 
 *      contents : The result contents 
 */
exports.getRecentActivityList = function(maxResults, callback) {
	step(
		function loadData() {
			getLatestIssues(MAX_RESULTS, this.parallel());
			getLatestComments(MAX_RESULTS, this.parallel());
		},
		function handleCallback(err, issues, comments) {
			if (err) throw error;
			
			var all_results = []; 
			
			function dateComparator(a, b) {
				var a = new Date(a.contents.created), b = new Date(b.contents.created);
				return (b.getTime() - a.getTime());
			}
			
			for (i in issues) { 
				all_results.push({ 'type' : 'issue', 'contents' : issues[i] }); 
			}
			for (c in comments) {
				all_results.push({ 'type' : 'comment', 'contents' : comments[c] }); 
			}
			
			all_results.sort(dateComparator); 
			callback(null, all_results.slice(0, maxResults));
		}
	);
}

/* getUserRecentActivityList 
 * Returns a list of recent activity (e.g. issues and comments) for a user 
 * 
 * 'userId' The id of the user 
 * 'maxResults' The maximum number of results to return 
 * 'callback' A callback which returns an object with the following properties: 
 *      type : The type of results (e.g. 'issue' or 'comment') 
 *      contents : The result contents 
 *      relevance : The relevance score 
 */ 
exports.getUserRecentActivityList = function(userId, maxResults, callback) {
	step(
		function loadData() {
			getInterests(userId, this.parallel());
			getLatestIssues(MAX_RESULTS, this.parallel());
			getLatestComments(MAX_RESULTS, this.parallel());
			getUserLocation(userId, this.parallel()); 
		},
		function handleCallback(err, interests, issues, comments, neighborhood) {
			if (err) throw error;
			
			var all_results = []; 
			
			function dateComparator(a, b) {
				var a = new Date(a.contents.created), b = new Date(b.contents.created);
				return (b.getTime() - a.getTime());
			}
			
			function relevanceComparator(a, b) {
				return b.relevance - a.relevance; 
			}
			
			// Rank issues and comments 
			var foundInterests = (interests.length == 0) ? false: true; 
			for (i in issues) { 
				var issueRank = foundInterests ? rankIssueToInterests(issues[i], interests[0]) : 0;
				issueRank += rankIssueToLocation(issues[i], neighborhood); 
				all_results.push({ 'type' : 'issue', 'contents' : issues[i], 'relevance' : issueRank }); 
			}
			for (c in comments) {
				var commentRank = foundInterests ? rankCommentToInterests(comments[c], interests[0]) : 0; 
				commentRank += rankCommentToLocation(comments[c], neighborhood); 
				all_results.push({ 'type' : 'comment', 'contents' : comments[c], 'relevance' : commentRank }); 
			}
			
			// Sort results 
			if (foundInterests) {
				all_results.sort(relevanceComparator); 
			}
			else { 
				all_results.sort(dateComparator); 
			}
			all_results = all_results.slice(0, maxResults); 
			callback(null, all_results);
		}
	);
}

/* rankIssueToLocation
 * Determines the relevance of an issue based on the frequency of matches a user's location 
 * 
 * 'issue' The issue 
 * 'neighborhood' The user's neighborhood  
 */ 
function rankIssueToLocation(issue, neighborhood) {
	var rank = 0; 
	var neighborhoodParts = new String(neighborhood).split(/\s+/); 
	rank += countMatchesToInterests(issue.description, neighborhoodParts);
	rank += countMatchesToInterests(issue.title, neighborhoodParts);
	return rank; 
}

/* rankCommentToLocation 
 * Determines the relevance of a comment based on the frequency of matches a user's location 
 * 
 * 'issue' The comment 
 * 'neighborhood' The user's neighborhood  
 */ 
function rankCommentToLocation(comment, neighborhood) {
	var rank = 0; 
	var neighborhoodParts = new String(neighborhood).split(/\s+/); 
	rank += countMatchesToInterests(comment.content, neighborhoodParts);
	return rank; 
}

/* rankIssueToInterests 
 * Determines the relevance of an issue based on the frequency of matches to interests 
 * 
 * 'issue' The issue 
 * 'interests' The user interests 
 */ 
function rankIssueToInterests(issue, interests) {
	var rank = 0;
	var topics = createInterestList(interests.interest_topic); 	
	var locations = createInterestList(interests.interest_location); 	
	rank += countMatchesToInterests(issue.description, topics);
	rank += countMatchesToInterests(issue.title, topics);
	rank += countMatchesToInterests(issue.description, locations);
	rank += countMatchesToInterests(issue.title, locations);
	// TODO: Get issue tags once it is implemented 
	return rank; 
}

/* countMatchesToInterests 
 * Counts the number of matches 
 * 
 * 'text' The text to look for matches in 
 * 'interestList' A list of interests  
 */ 
function countMatchesToInterests(text, interestList) {
	var regex = buildRegExpQuery(interestList); 
	var matches = text.match(regex);
	return (matches == null) ? 0 : matches.length; 
}

/* rankCommentToInterests 
 * Determines the relevance of a comment based on the frequency of matches to interests 
 * 
 * 'comment' The comment
 * 'interests' The user interests 
 */ 
function rankCommentToInterests(comment, interests) { 
	var rank = 0; 
	var topics = createInterestList(interests.interest_topic); 	
	var locations = createInterestList(interests.interest_location); 	
	rank += countMatchesToInterests(comment.content, topics);
	rank += countMatchesToInterests(comment.content, locations);
	return rank; 
}

/* rankTagsToInterests 
 * Determines the relevance of a issue tags based on the frequency of matches to interests 
 * 
 * 'tagList' The issue's tag list 
 * 'interests' The user interests 
 *
 * TODO: Should finish implement when tag retrieval feature is finished 
 */ 
function rankTagsToInterests(tagList, interests) {
	var tags = tagList.join(' '); 
	countMatchesToInterests(tags, interests); 
}

/* buildRegExpQuery 
 * Creates a new regular expression which will search a string for matches to any of the defined search terms 
 * 
 * 'terms' An array of terms to search for 
 */ 
function buildRegExpQuery(terms) {
	var pattern = ''; 
	for (var i = 0; i < terms.length; i++) { 
		pattern += '\\b' + terms[i] + '\\b'; 
		if (i + 1 != terms.length) {
			pattern += '|' 
		}
	} 
	return new RegExp(pattern, 'ig');
}

/* createInterestList 
 * Builds an array from a string list of interests 
 * 
 * 'interests' A string list of interests (which are internally seperated by commas) 
 */ 
function createInterestList(interests) {
	var i = interests.replace(',', ' '); 
	return i.split(/\s+/); 
}
