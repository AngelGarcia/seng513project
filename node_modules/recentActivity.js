/* recentActivity.js 
 * Aggregates recent events (issue created, comments added, comments/issues voted) 
 * based on a person's interests in issues, topics and locations
 */ 
 
var dbAccess = require('dbAccess'),
	step = require('step'), 
	parseAddr = require('parseAddr'), 
	util = require('util');  

/* getLatestIssues 
 * Returns the latest issues. A maximum number of issues to return can be specified 
 *
 * 'numIssues' The maximum number of issues to return 
 * 'call_back' A call_back with (error, results) 
 */ 
function getLatestIssues(numIssues, call_back) { 
	var maxIssues = (numIssues < 0) ? -1 : numIssues; 
	dbAccess.find('issues', { orderby: 'created DESC', limit: maxIssues }, function(error, results) {
		call_back(error, results); 
	});
}

/* getLatestComments  
 * Returns the latest comments. A maximum number of comments to return can be specified 
 *
 * 'numComments' The maximum number of issues to return 
 * 'call_back' A call_back with (error, results) 
 */
function getLatestComments(numComments, call_back) { 
	var maxComments = (numComments < 0) ? -1 : numComments; 
	dbAccess.find('comments', { orderby: 'created DESC', limit: numComments }, function(error, results) {
		call_back(error, results); 
	});
}

/* getInterests 
 * Gets the interests for a user 
 *
 * 'userId' The id of the user 
 * 'call_back' A call_back with (error, results) 
 */ 
function getInterests(userId, call_back) { 
	dbAccess.find('interests', { conditions: ['user_id="' + userId + '"'] }, function(error, results) { 
		call_back(error, results); 
	});
}

exports.getRecentActivityList = function(userId, call_back) {
	step(
		function loadData() {
			getInterests(userId, this.parallel());
			getLatestIssues(100, this.parallel());
			getLatestComments(100, this.parallel()); 
		},
		function handleCallback(err, interests, issues, comments) {
			if (err) throw error;
			
			console.log('interests: ' + interests.length); 
			console.log('issues: ' + issues.length); 
			console.log('comments: ' + comments.length);
			
			var all_results = []; 
			function dateSort(a, b) {
				var a = new Date(a.contents.created), b = new Date(b.contents.created);
				return (b.getTime() - a.getTime());
			}
			
			if (interests.length == 0) { 
				for (i in issues) {
					all_results.push({ 'type' : 'issue', 'contents' : issues[i] }); 
				}
				for (c in comments) { 
					all_results.push({ 'type' : 'comment', 'contents' : comments[c] }); 
				}
				all_results.sort(dateSort); 
				call_back(null, all_results); 
			}
			else { 
				for (i in issues) {
					all_results.push({ 'type' : 'issue', 'contents' : issues[i] }); 
				}
				for (c in comments) { 
					all_results.push({ 'type' : 'comment', 'contents' : comments[c] }); 
				}
				all_results.sort(dateSort); 
				call_back(null, all_results); 
			}
		}
	);
}

function rankIssueToLocation(issue, neighborhood) {
	countMatchesToInterests(issue, [neighborhood]); 
}

function rankIssueToInterests(issue, interests) {
	var rank = 0; 
	numMatches += countMatchesToInterests(issue.description, interests);
	numMatches += countMatchesToInterests(issue.title, interests);
	// TODO: Get issue tags once it is implemented 
	return rank; 
}

function countMatchesToInterests(text, interests) {
	var regex = buildRegExpQuery(interests); 
	var matches = tags.match(regex);
	return matches.length; 
}

function rankCommentToInterests(comment, interests) { 
	return countMatchesToInterests(comment, interests);
}

function rankTagsToInterests(tagList, interests) {
	var tags = tagList.join(' '); 
	countMatchesToInterests(tags, interests); 
}

function buildRegExpQuery(terms) {
	var pattern = ''; 
	for (var i = 0; i < terms.length; i++) { 
		pattern += '\b' + terms[i] + '\b'; 
		if (i + 1 != terms.length) {
			pattern += '|' 
		}
	}
	return new RegExp(pattern, 'ig');
}
